{"ast":null,"code":"import { Observable, Subscription, asapScheduler, ReplaySubject, isObservable, of, queueScheduler, EMPTY, throwError, scheduled, combineLatest, Subject } from 'rxjs';\nimport { take, observeOn, tap, withLatestFrom, map, catchError, takeUntil, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, isDevMode, Injectable, Optional, Inject } from '@angular/core';\n/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nfunction debounceSync() {\n  return source => new Observable(observer => {\n    let actionSubscription;\n    let actionValue;\n    const rootSubscription = new Subscription();\n    rootSubscription.add(source.subscribe({\n      complete: () => {\n        if (actionSubscription) {\n          observer.next(actionValue);\n        }\n\n        observer.complete();\n      },\n      error: error => {\n        observer.error(error);\n      },\n      next: value => {\n        actionValue = value;\n\n        if (!actionSubscription) {\n          actionSubscription = asapScheduler.schedule(() => {\n            observer.next(actionValue);\n            actionSubscription = undefined;\n          });\n          rootSubscription.add(actionSubscription);\n        }\n      }\n    }));\n    return rootSubscription;\n  });\n}\n/**\n * Checks to see if the OnInitStore lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\n\n\nfunction isOnStoreInitDefined(cs) {\n  return typeof cs.ngrxOnStoreInit === 'function';\n}\n/**\n * Checks to see if the OnInitState lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\n\n\nfunction isOnStateInitDefined(cs) {\n  return typeof cs.ngrxOnStateInit === 'function';\n}\n/**\n * @description\n *\n * Function that returns the ComponentStore\n * class registered as a provider,\n * and uses a factory provider to instantiate the\n * ComponentStore and run the lifecycle hooks\n * defined on the ComponentStore.\n *\n * @param componentStoreClass The ComponentStore with lifecycle hooks\n * @returns Provider[]\n *\n * @usageNotes\n *\n * ```ts\n * @Injectable()\n * export class MyStore\n *    extends ComponentStore<{ init: boolean }>\n *    implements OnStoreInit, OnStateInit\n *   {\n *\n *   constructor() {\n *     super({ init: true });\n *   }\n *\n *   ngrxOnStoreInit() {\n *     // runs once after store has been instantiated\n *   }\n *\n *   ngrxOnStateInit() {\n *     // runs once after store state has been initialized\n *   }\n * }\n *\n * @Component({\n *   providers: [\n *     provideComponentStore(MyStore)\n *   ]\n * })\n * export class MyComponent {\n *   constructor(private myStore: MyStore) {}\n * }\n * ```\n */\n\n\nfunction provideComponentStore(componentStoreClass) {\n  const CS_WITH_HOOKS = new InjectionToken('@ngrx/component-store ComponentStore with Hooks');\n  return [{\n    provide: CS_WITH_HOOKS,\n    useClass: componentStoreClass\n  }, {\n    provide: componentStoreClass,\n    useFactory: () => {\n      const componentStore = inject(CS_WITH_HOOKS); // Set private property that CS has been provided with lifecycle hooks\n\n      componentStore['ɵhasProvider'] = true;\n\n      if (isOnStoreInitDefined(componentStore)) {\n        componentStore.ngrxOnStoreInit();\n      }\n\n      if (isOnStateInitDefined(componentStore)) {\n        componentStore.state$.pipe(take(1)).subscribe(() => componentStore.ngrxOnStateInit());\n      }\n\n      return componentStore;\n    }\n  }];\n}\n\nconst INITIAL_STATE_TOKEN = new InjectionToken('@ngrx/component-store Initial State');\nlet ComponentStore = /*#__PURE__*/(() => {\n  class ComponentStore {\n    constructor(defaultState) {\n      // Should be used only in ngOnDestroy.\n      this.destroySubject$ = new ReplaySubject(1); // Exposed to any extending Store to be used for the teardown.\n\n      this.destroy$ = this.destroySubject$.asObservable();\n      this.stateSubject$ = new ReplaySubject(1);\n      this.isInitialized = false; // Needs to be after destroy$ is declared because it's used in select.\n\n      this.state$ = this.select(s => s);\n      this.ɵhasProvider = false; // State can be initialized either through constructor or setState.\n\n      if (defaultState) {\n        this.initState(defaultState);\n      }\n\n      this.checkProviderForHooks();\n    }\n    /** Completes all relevant Observable streams. */\n\n\n    ngOnDestroy() {\n      this.stateSubject$.complete();\n      this.destroySubject$.next();\n    }\n    /**\n     * Creates an updater.\n     *\n     * Throws an error if updater is called with synchronous values (either\n     * imperative value or Observable that is synchronous) before ComponentStore\n     * is initialized. If called with async Observable before initialization then\n     * state will not be updated and subscription would be closed.\n     *\n     * @param updaterFn A static updater function that takes 2 parameters (the\n     * current state and an argument object) and returns a new instance of the\n     * state.\n     * @return A function that accepts one argument which is forwarded as the\n     *     second argument to `updaterFn`. Every time this function is called\n     *     subscribers will be notified of the state change.\n     */\n\n\n    updater(updaterFn) {\n      return observableOrValue => {\n        // We need to explicitly throw an error if a synchronous error occurs.\n        // This is necessary to make synchronous errors catchable.\n        let isSyncUpdate = true;\n        let syncError; // We can receive either the value or an observable. In case it's a\n        // simple value, we'll wrap it with `of` operator to turn it into\n        // Observable.\n\n        const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n        const subscription = observable$.pipe( // Push the value into queueScheduler\n        observeOn(queueScheduler), // If the state is not initialized yet, we'll throw an error.\n        tap(() => this.assertStateIsInitialized()), withLatestFrom(this.stateSubject$), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        map(([value, currentState]) => updaterFn(currentState, value)), tap(newState => this.stateSubject$.next(newState)), catchError(error => {\n          if (isSyncUpdate) {\n            syncError = error;\n            return EMPTY;\n          }\n\n          return throwError(() => error);\n        }), takeUntil(this.destroy$)).subscribe();\n\n        if (syncError) {\n          throw syncError;\n        }\n\n        isSyncUpdate = false;\n        return subscription;\n      };\n    }\n    /**\n     * Initializes state. If it was already initialized then it resets the\n     * state.\n     */\n\n\n    initState(state) {\n      scheduled([state], queueScheduler).subscribe(s => {\n        this.isInitialized = true;\n        this.stateSubject$.next(s);\n      });\n    }\n    /**\n     * Sets the state specific value.\n     * @param stateOrUpdaterFn object of the same type as the state or an\n     * updaterFn, returning such object.\n     */\n\n\n    setState(stateOrUpdaterFn) {\n      if (typeof stateOrUpdaterFn !== 'function') {\n        this.initState(stateOrUpdaterFn);\n      } else {\n        this.updater(stateOrUpdaterFn)();\n      }\n    }\n    /**\n     * Patches the state with provided partial state.\n     *\n     * @param partialStateOrUpdaterFn a partial state or a partial updater\n     * function that accepts the state and returns the partial state.\n     * @throws Error if the state is not initialized.\n     */\n\n\n    patchState(partialStateOrUpdaterFn) {\n      const patchedState = typeof partialStateOrUpdaterFn === 'function' ? partialStateOrUpdaterFn(this.get()) : partialStateOrUpdaterFn;\n      this.updater((state, partialState) => ({ ...state,\n        ...partialState\n      }))(patchedState);\n    }\n\n    get(projector) {\n      this.assertStateIsInitialized();\n      let value;\n      this.stateSubject$.pipe(take(1)).subscribe(state => {\n        value = projector ? projector(state) : state;\n      }); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      return value;\n    }\n\n    select(...args) {\n      const {\n        observablesOrSelectorsObject,\n        projector,\n        config\n      } = processSelectorArgs(args);\n      const source$ = hasProjectFnOnly(observablesOrSelectorsObject, projector) ? this.stateSubject$ : combineLatest(observablesOrSelectorsObject);\n      return source$.pipe(config.debounce ? debounceSync() : noopOperator(), projector ? map(projectorArgs => // projectorArgs could be an Array in case where the entire state is an Array, so adding this check\n      observablesOrSelectorsObject.length > 0 && Array.isArray(projectorArgs) ? projector(...projectorArgs) : projector(projectorArgs)) : noopOperator(), distinctUntilChanged(), shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }), takeUntil(this.destroy$));\n    }\n    /**\n     * Creates an effect.\n     *\n     * This effect is subscribed to throughout the lifecycle of the ComponentStore.\n     * @param generator A function that takes an origin Observable input and\n     *     returns an Observable. The Observable that is returned will be\n     *     subscribed to for the life of the component.\n     * @return A function that, when called, will trigger the origin Observable.\n     */\n\n\n    effect(generator) {\n      const origin$ = new Subject();\n      generator(origin$) // tied to the lifecycle 👇 of ComponentStore\n      .pipe(takeUntil(this.destroy$)).subscribe();\n      return observableOrValue => {\n        const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n        return observable$.pipe(takeUntil(this.destroy$)).subscribe(value => {\n          // any new 👇 value is pushed into a stream\n          origin$.next(value);\n        });\n      };\n    }\n    /**\n     * Used to check if lifecycle hooks are defined\n     * but not used with provideComponentStore()\n     */\n\n\n    checkProviderForHooks() {\n      asapScheduler.schedule(() => {\n        if (isDevMode() && (isOnStoreInitDefined(this) || isOnStateInitDefined(this)) && !this.ɵhasProvider) {\n          const warnings = [isOnStoreInitDefined(this) ? 'OnStoreInit' : '', isOnStateInitDefined(this) ? 'OnStateInit' : ''].filter(defined => defined);\n          console.warn(`@ngrx/component-store: ${this.constructor.name} has the ${warnings.join(' and ')} ` + 'lifecycle hook(s) implemented without being provided using the ' + `provideComponentStore(${this.constructor.name}) function. ` + `To resolve this, provide the component store via provideComponentStore(${this.constructor.name})`);\n        }\n      });\n    }\n\n    assertStateIsInitialized() {\n      if (!this.isInitialized) {\n        throw new Error(`${this.constructor.name} has not been initialized yet. ` + `Please make sure it is initialized before updating/getting.`);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n  ComponentStore.ɵfac = function ComponentStore_Factory(t) {\n    return new (t || ComponentStore)(i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n  };\n  /** @nocollapse */\n\n\n  ComponentStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ComponentStore,\n    factory: ComponentStore.ɵfac\n  });\n  return ComponentStore;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction processSelectorArgs(args) {\n  const selectorArgs = Array.from(args); // Assign default values.\n\n  let config = {\n    debounce: false\n  }; // Last argument is either config or projector or selectorsObject\n\n  if (isSelectConfig(selectorArgs[selectorArgs.length - 1])) {\n    config = { ...config,\n      ...selectorArgs.pop()\n    };\n  } // At this point selectorArgs is either projector, selectors with projector or selectorsObject\n\n\n  if (selectorArgs.length === 1 && typeof selectorArgs[0] !== 'function') {\n    // this is a selectorsObject\n    return {\n      observablesOrSelectorsObject: selectorArgs[0],\n      projector: undefined,\n      config\n    };\n  }\n\n  const projector = selectorArgs.pop(); // The Observables to combine, if there are any left.\n\n  const observables = selectorArgs;\n  return {\n    observablesOrSelectorsObject: observables,\n    projector,\n    config\n  };\n}\n\nfunction isSelectConfig(arg) {\n  return typeof arg.debounce !== 'undefined';\n}\n\nfunction hasProjectFnOnly(observablesOrSelectorsObject, projector) {\n  return Array.isArray(observablesOrSelectorsObject) && observablesOrSelectorsObject.length === 0 && projector;\n}\n\nfunction noopOperator() {\n  return source$ => source$;\n}\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate.\n * It enforces that the error case is handled and that the effect would still be\n * running should an error occur.\n *\n * Takes an optional third argument for a `complete` callback.\n *\n * ```typescript\n * readonly dismissedAlerts = this.effect<Alert>(alert$ => {\n *  return alert$.pipe(\n *      concatMap(\n *          (alert) => this.alertsService.dismissAlert(alert).pipe(\n *              tapResponse(\n *                 (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *                 (error: { message: string }) => this.logError(error.message),\n *              ))));\n *   });\n * ```\n */\n\n\nfunction tapResponse(nextFn, errorFn, completeFn) {\n  return source => source.pipe(tap({\n    next: nextFn,\n    complete: completeFn\n  }), catchError(e => {\n    errorFn(e);\n    return EMPTY;\n  }));\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ComponentStore, INITIAL_STATE_TOKEN, provideComponentStore, tapResponse }; //# sourceMappingURL=ngrx-component-store.mjs.map\n//# sourceMappingURL=ngrx-component-store.mjs.map","map":null,"metadata":{},"sourceType":"module"}